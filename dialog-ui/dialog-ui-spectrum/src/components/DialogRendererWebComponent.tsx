import React from 'react';
import r2wc from '@r2wc/react-to-web-component';
import {EnhancedDialogBody} from './EnhancedDialogBody';
import {DialogConfig, FieldConfig} from '@ethereal-nexus/dialog-ui-core';
import {SpectrumAEMAdapterConfig} from '../adapters';
import {SpectrumAEMAdapterFactory} from '../adapters/SpectrumAEMAdapterFactory';

// Store reference to current form data and adapter for external button access
let currentFormData: any = {};
let currentAdapter: any = null;
let currentFormValid = false;

// Function to bind external submit buttons
const bindExternalSubmitButtons = () => {
    const submitButtons = document.querySelectorAll('.ethereal-submit-button');

    if (submitButtons.length === 0) {
        console.warn('üîç No buttons with class "ethereal-submit-button" found on the page');
        return;
    }

    console.log(`üéØ Found ${submitButtons.length} external submit button(s) with class "ethereal-submit-button"`);

    submitButtons.forEach((button, index) => {
        console.log(`üîó Binding external submit button ${index + 1}`);

        // Remove any existing listeners to avoid duplicates
        const newButton = button.cloneNode(true);
        button.parentNode?.replaceChild(newButton, button);

        newButton.addEventListener('click', async () => {

            console.log('üéØ External submit button clicked');
            console.log('üîç Current form state:', {
                currentFormValid,
                hasFormData: !!currentFormData,
                formDataKeys: currentFormData ? Object.keys(currentFormData) : []
            });

            if (!currentFormValid) {
                console.log('‚ùå Form validation failed - cannot submit');
                console.log('üîç Debug: currentFormValid =', currentFormValid);
                console.log('üîç Debug: Form errors might be present or required fields missing');
                return;
            }

            if (!currentAdapter) {
                console.warn('‚ö†Ô∏è No AEM adapter configured - cannot save');
                return;
            }

            try {
                console.log('üíæ Starting save from external button with form data:', currentFormData);

                // Use the same saveContent method as the React component (maintains previous behavior)
                const saveResult = await currentAdapter.saveContent(currentFormData);

                if (saveResult.success) {
                    console.log('üéâ External button save successful!');

                    // Dispatch success event
                    const successEvent = new CustomEvent('dialog-save-success', {
                        detail: currentFormData,
                        bubbles: true
                    });
                    document.dispatchEvent(successEvent);
                } else {
                    console.error('‚ùå External button save failed:', saveResult.error);

                    // Dispatch error event
                    const errorEvent = new CustomEvent('dialog-save-error', {
                        detail: {error: saveResult.error || 'Save failed'},
                        bubbles: true
                    });
                    document.dispatchEvent(errorEvent);
                }

            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                console.error('üí• Exception during external button save:', errorMessage);

                // Dispatch error event
                const errorEvent = new CustomEvent('dialog-save-error', {
                    detail: {error: errorMessage},
                    bubbles: true
                });
                document.dispatchEvent(errorEvent);
            }
        });
    });
};

// Props interface for the web component
interface DialogRendererProps {
    config?: string; // JSON string of DialogConfig or AEM field array
    'data-config'?: string; // Alternative attribute name
    'content-resource'?: string; // JSON string of AEM content resource data
    'data-content-resource'?: string; // Alternative attribute name for content resource
    'data-component-path'?: string; // AEM component path (auto-generated by DialogGenerator)
    'data-component-type'?: string; // AEM component type (auto-generated by DialogGenerator)
    'data-containing-page'?: string; // AEM containing page path (auto-generated by DialogGenerator)
    'data-enable-aem-save'?: string; // Enable AEM servlet integration (auto-generated by DialogGenerator)
    onSubmit?: (data: any) => void;
}


const calculateChildFieldParentId = (parentId: string, field: any): string | null => {


    const isTabField = field.type === "tab" || field.type === "tabs";

    if (!isTabField) {
      if (field.type === "multifield") {
        return parentId ? `${parentId}.${field.id}[$INDEX]` : `${field.id}[$INDEX]`;
      }
      return parentId ? `${parentId}.${field.id}` : field.id;
    } else if (isTabField) {
      return parentId;
    }

    return field.id;
}

// Transform AEM field format to our DialogConfig format
const transformAEMFields = (aemFields: any[]): DialogConfig => {
    const transformField = (field: any, parentId: any): FieldConfig => {
        return {
            id: field.id || field.name, // Use 'id' from AEM format, fallback to 'name'
            name: field.name || field.id, // Provide name for backward compatibility
            label: field.label || field.title || field.id,
            parentId: parentId ?? undefined,
            type: field.type,
            multiple: field.multiple || false,
            defaultValue: field.defaultValue,
            required: field.required || false,
            placeholder: field.placeholder || '',
            tooltip: field.tooltip || null,
            url: field.url || undefined,
            method: field.method || undefined,
            body: field.body || undefined,
            condition: field.condition || undefined,
            itemLabelKey: field.itemLabelKey ?? undefined,
            showastoggle: field.showastoggle || false, // Add showastoggle property from AEM config
            children: field.children ? field.children.map((c: any) => transformField(c, calculateChildFieldParentId(parentId, field))) : undefined,
            options: field.options || field.values ? (field.options || field.values).map((value: any) => ({
                value: value.value || value,
                label: value.label || value.text || value.value || value
            })) : undefined
        };
    };

    return {
        fields: aemFields.map((field) => transformField(field, undefined))
    };
};

// Transform AEM content resource to form values
const extractFormValuesFromContentResource = (contentResource: any): any => {
    console.log('Starting extraction from content resource:', contentResource);

    const extractValues = (obj: any, depth = 0): any => {
        const values: any = {};

        if (!obj || typeof obj !== 'object') {
            return values;
        }

        // Skip JCR metadata properties
        const skipProps = ['jcr:primaryType', 'jcr:created', 'jcr:createdBy', 'jcr:lastModified', 'jcr:lastModifiedBy', 'sling:resourceType', 'remoteComponentType', 'remoteComponentTitle'];

        console.log(`Extracting at depth ${depth} from:`, Object.keys(obj));

        for (const [key, value] of Object.entries(obj)) {
            if (skipProps.includes(key)) {
                continue;
            }

            if (value && typeof value === 'object') {
                // Check if this is a multifield structure (contains item0, item1, etc.)
                const keys = Object.keys(value);
                const isMultifield = keys.some(k => k.startsWith('item'));

                if (isMultifield) {
                    console.log(`Found multifield structure for key: ${key}`);
                    // Extract multifield items
                    const items = keys
                        .filter(k => k.startsWith('item'))
                        .sort() // Ensure proper order (item0, item1, item2, etc.)
                        .map(itemKey => {
                            const itemValue = (value as any)[itemKey];
                            console.log(`Processing multifield item ${itemKey}:`, itemValue);

                            let extracted: any;
                            // If the item has a 'remote' wrapper, extract from it
                            if (itemValue && itemValue.remote) {
                                extracted = extractValues(itemValue.remote, depth + 1);
                            } else if (itemValue) {
                                // Skip jcr:primaryType and extract the rest
                                const filtered = Object.fromEntries(
                                    Object.entries(itemValue).filter(([k]) => !skipProps.includes(k))
                                );
                                extracted = extractValues(filtered, depth + 1);
                            } else {
                                extracted = {};
                            }
                            // Preserve the original item key for display purposes
                            extracted.__itemKey = itemKey;
                            return extracted;
                        });
                    values[key] = items;
                    console.log(`Set multifield ${key} to:`, items);
                } else if (Array.isArray(value) && value.every(item =>
                    typeof item === 'string' ||
                    typeof item === 'number' ||
                    typeof item === 'boolean' ||
                    item === null ||
                    item === undefined
                )) {
                    values[key] = value;
                } else if (key === 'remote') {
                    // Handle 'remote' wrapper - extract its contents and merge with current level
                    console.log('Processing remote wrapper, extracting contents...');
                    const remoteValues = extractValues(value, depth + 1);
                    Object.assign(values, remoteValues);
                    console.log('Merged remote values:', remoteValues);
                } else {
                    // Regular nested object - extract its values
                    const nestedValues = extractValues(value, depth + 1);
                    if (Object.keys(nestedValues).length > 0) {
                        values[key] = nestedValues;
                        console.log(`Set nested object ${key} to:`, nestedValues);
                    }
                }
            } else {
                // Primitive value - store directly
                values[key] = value;
                console.log(`Set primitive ${key} = ${value}`);
            }
        }

        console.log(`Returning values at depth ${depth}:`, values);
        return values;
    };

    // Start extraction from the root, but if there's a top-level 'remote', start from there
    const startPoint = contentResource.remote || contentResource;
    const result = extractValues(startPoint);

    console.log('Final extracted values:', result);
    return result;
};

// React component that will be converted to web component
export const DialogRendererReact: React.FC<DialogRendererProps> = (props) => {
    // Parse config from props
    const getConfig = (): DialogConfig | null => {
        try {
            const configStr = props.config || props['data-config'];
            if (!configStr) {
                console.warn('DialogRenderer: No config provided');
                return null;
            }

            // Clean up the JSON string - remove any leading/trailing whitespace and handle common issues
            const cleanedConfigStr = configStr.trim();

            // Check if the string is empty after trimming
            if (!cleanedConfigStr) {
                console.warn('DialogRenderer: Config string is empty');
                return null;
            }

            // Check if it's already a JavaScript object (not a string)
            let parsedConfig;

            if (typeof configStr === 'object') {
                parsedConfig = configStr;
            } else {
                // Attempt to parse JSON with better error handling
                try {
                    parsedConfig = JSON.parse(cleanedConfigStr);
                } catch (parseError) {
                    console.error('DialogRenderer: JSON parse error for config:', parseError);
                    console.error('DialogRenderer: Problematic config string:', cleanedConfigStr);
                    console.error('DialogRenderer: First 100 characters:', cleanedConfigStr.substring(0, 100));
                    return null;
                }
            }

            // Check if it's already in DialogConfig format (has 'fields' property)
            if (parsedConfig.fields && Array.isArray(parsedConfig.fields)) {
                return parsedConfig as DialogConfig;
            }

            // Check if it's an AEM field array format
            if (Array.isArray(parsedConfig)) {
                console.log('Transforming AEM field array format to DialogConfig');
                return transformAEMFields(parsedConfig);
            }

            // If it's a single field object, wrap it in an array
            if (parsedConfig.type) {
                console.log('Transforming single field to DialogConfig');
                return transformAEMFields([parsedConfig]);
            }

            console.warn('DialogRenderer: Unrecognized config format:', parsedConfig);
            return null;
        } catch (error) {
            console.error('DialogRenderer: Unexpected error in getConfig:', error);
            return null;
        }
    };

    // Parse content resource from props to get initial form values
    const getInitialValues = (): any => {
        try {
            const contentResourceStr = props['content-resource'] || props['data-content-resource'];
            if (!contentResourceStr) {
                return {};
            }

            // Clean up the JSON string
            const cleanedResourceStr = contentResourceStr.trim();

            if (!cleanedResourceStr) {
                return {};
            }

            let parsedResource;
            if (typeof contentResourceStr === 'object') {
                parsedResource = contentResourceStr;
            } else {
                try {
                    parsedResource = JSON.parse(cleanedResourceStr);
                } catch (parseError) {
                    console.error('DialogRenderer: JSON parse error for content-resource:', parseError);
                    console.error('DialogRenderer: Problematic content-resource string:', cleanedResourceStr);
                    return {};
                }
            }

            const extractedValues = extractFormValuesFromContentResource(parsedResource);

            console.log('Extracted form values from content resource:', extractedValues);
            return extractedValues;
        } catch (error) {
            console.error('DialogRenderer: Unexpected error in getInitialValues:', error);
            return {};
        }
    };

    // Get AEM adapter configuration if AEM integration is enabled
    const getAEMAdapterConfig = (): SpectrumAEMAdapterConfig | null => {
        const enableAemSave = props['data-enable-aem-save'];
        const componentPath = props['data-component-path'];
        const componentType = props['data-component-type'];
        const containingPage = props['data-containing-page'];

        console.log('üîç AEM Integration Debug - Props received:', {
            'data-enable-aem-save': props['data-enable-aem-save'],
            'data-component-path': props['data-component-path'],
            'data-component-type': props['data-component-type'],
            'data-containing-page': props['data-containing-page']
        });

        console.log('üîç AEM Integration Debug - Processed values:', {
            enableAemSave,
            componentPath,
            componentType,
            containingPage
        });

        // Check if AEM integration is enabled and we have required data
        if (enableAemSave === 'true' && componentPath && componentType && containingPage) {
            const config = {
                baseUrl: window.location.origin, // Use current domain as AEM URL
                componentPath,
                componentType,
                containingPage,
                debug: process.env.NODE_ENV === 'development'
            };

            console.log('‚úÖ AEM Integration ENABLED - Config created:', config);
            return config;
        }

        console.log('‚ùå AEM Integration DISABLED - Missing required props or enableAemSave !== "true"');
        return null;
    };

    const config = getConfig();
    const initialValues = getInitialValues();
    const aemAdapterConfig = getAEMAdapterConfig();

    // Initialize the adapter for external button access
    React.useEffect(() => {
        if (aemAdapterConfig) {
            const adapter = SpectrumAEMAdapterFactory.create(aemAdapterConfig);

            // Create the same saveContent wrapper that useSpectrumAEMAdapter provides
            currentAdapter = {
                adapter: adapter,
                saveContent: async (values: any) => {
                    try {
                        await adapter.saveFieldValues(values);
                        return {success: true};
                    } catch (error) {
                        console.error('Error saving content:', error);
                        return {success: false, error: error instanceof Error ? error.message : String(error)};
                    }
                }
            };

            console.log('üîó AEM adapter initialized for external button access');

            // Set up global state updater function
            if (typeof window !== 'undefined') {
                (window as any).updateEtherealFormState = (formData: any, isValid: boolean) => {
                    currentFormData = formData;
                    currentFormValid = isValid;
                    console.log('üìä Global form state updated via window function:', {isValid, hasData: !!formData});
                };
            }

            // Bind external buttons after adapter is ready
            setTimeout(() => {
                bindExternalSubmitButtons();
            }, 100); // Small delay to ensure DOM is ready
        } else {
            currentAdapter = null;
            console.log('üö´ No AEM adapter - external buttons will not be functional');

            // Clean up global state updater
            if (typeof window !== 'undefined') {
                delete (window as any).updateEtherealFormState;
            }
        }

        // Cleanup function
        return () => {
            if (typeof window !== 'undefined') {
                delete (window as any).updateEtherealFormState;
            }
        };
    }, [aemAdapterConfig]);

    // Update global form state when form data changes
    const handleFormDataChange = (formData: any, isValid: boolean) => {
        currentFormData = formData;
        currentFormValid = isValid;
        console.log('üìä Updated global form state:', {isValid, hasData: !!formData});
    };

    if (!config) {
        return (
            <div style={{
                padding: '20px',
                border: '2px dashed #ccc',
                borderRadius: '4px',
                textAlign: 'center',
                color: '#666'
            }}>
                <p>‚ö†Ô∏è Dialog Renderer</p>
                <p>No valid configuration provided</p>
                <small>Please provide a 'config' or 'data-config' attribute with valid JSON</small>
                <br/>
                <small style={{marginTop: '10px', display: 'block', fontFamily: 'monospace'}}>
                    Received config: {String(props.config || props['data-config'] || 'undefined')}
                </small>
            </div>
        );
    }

    const handleSubmit = (formData: any) => {
        // Update global state
        handleFormDataChange(formData, true);

        console.log('Dialog submitted:', formData);

        // Dispatch custom event for parent to listen to
        const event = new CustomEvent('dialog-submit', {
            detail: formData,
            bubbles: true
        });

        // If we have access to the host element, dispatch from there
        if (typeof window !== 'undefined' && document.querySelector('dialog-renderer')) {
            document.querySelector('dialog-renderer')?.dispatchEvent(event);
        }

        // Call prop callback if provided
        if (props.onSubmit) {
            props.onSubmit(formData);
        }
    };

    const handleSaveSuccess = (data: any) => {
        console.log('Dialog saved successfully to AEM:', data);

        // Dispatch success event
        const event = new CustomEvent('dialog-save-success', {
            detail: data,
            bubbles: true
        });

        if (typeof window !== 'undefined' && document.querySelector('dialog-renderer')) {
            document.querySelector('dialog-renderer')?.dispatchEvent(event);
        }
    };

    const handleSaveError = (error: string) => {
        console.error('Dialog save error:', error);

        // Dispatch error event
        const event = new CustomEvent('dialog-save-error', {
            detail: {error},
            bubbles: true
        });

        if (typeof window !== 'undefined' && document.querySelector('dialog-renderer')) {
            document.querySelector('dialog-renderer')?.dispatchEvent(event);
        }
    };



  return (<EnhancedDialogBody
    dialog={config}
    initialValues={initialValues}
    adapterConfig={aemAdapterConfig}
    onSubmit={handleSubmit}
    onSaveSuccess={handleSaveSuccess}
    onSaveError={handleSaveError}
  />)

};

// Convert React component to Web Component
export const DialogRendererWebComponent = r2wc(DialogRendererReact, {
    props: {
        config: 'string',
        'data-config': 'string',
        'content-resource': 'string',
        'data-content-resource': 'string',
        'data-component-path': 'string',
        'data-component-type': 'string',
        'data-containing-page': 'string',
        'data-enable-aem-save': 'string'
    }
});

// Register the web component
if (typeof window !== 'undefined' && typeof customElements !== 'undefined') {
    // Only register if not already registered
    if (!customElements.get('dialog-renderer')) {
        customElements.define('dialog-renderer', DialogRendererWebComponent);
        console.log('‚úÖ dialog-renderer web component registered');
    }
}

export default DialogRendererWebComponent;
